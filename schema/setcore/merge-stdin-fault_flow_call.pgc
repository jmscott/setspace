/*
 *  Synopsis:
 *  	Merge a row and stdin into tables setcore.fault_flow_call{_output}.
 *  Usage:
 *	merge-stdin-fault_flow_call
 *  Arguments:
 *  	1	schema name
 *  	2	call name
 *	3	blob
 *	4	exit class {ERR, SIG}
 *	5	exit status
 *	6	signal
 *	
 *  Exit Status:
 *  	0	ok, tuple was merged
 *	1	sql error
 *	2	unexpected error
 */
#include "jmscott/libjmscott.h"

char *jmscott_progname = "merge-stdin-fault_flow_call";

#define EXIT_OK		0
#define EXIT_BAD_SQL	1
#define EXIT_BAD	2

extern int jmscott_ecpg_error_code;
extern int jmscott_ecpg_warn_code;

//  ignore these sql errors

static struct jmscott_ecpg_state_fault no_warn[] =
{
        {"02000", 0},                //  no data for conflict on upsert/insert
        {(char *)0, 0}
};

static char *usage = "merge-stdin-fault_flow_call schema command ...";

int
main(int argc, char **argv)
{
	//int input_size = 0;

EXEC SQL BEGIN DECLARE SECTION;
	char *schema_name;
	char *call_name;
	char *blob;
	char *exit_class;
	char *exit_status;
	char *signal;
	VARCHAR stderr[4096+1];

EXEC SQL END DECLARE SECTION;

	if (argc != 7)
		jmscott_die_argc(EXIT_BAD, argc, 7, usage);
	jmscott_close(1);

	schema_name = argv[1];
	call_name = argv[2];
	blob = argv[3];
	exit_class = argv[4];
	exit_status = argv[5];
	signal = argv[6];

	ssize_t nr = 0;
	char *sp = stderr.arr; 

	while ((nr = jmscott_read(0, (void *)sp, 4096 - (sp - stderr.arr))) > 0)
		sp += nr;
	if (nr < 0)
		jmscott_die2(EXIT_BAD, "read(stdin) failed", strerror(errno));
	*sp = 0;

	jmscott_ecpg_error_code = EXIT_BAD_SQL;
	jmscott_ecpg_warn_code = EXIT_BAD_SQL;
	EXEC SQL WHENEVER SQLERROR CALL jmscott_ecpg_error(
		(struct jmscott_ecpg_state_fault *)0
	);
	EXEC SQL WHENEVER SQLWARNING CALL jmscott_ecpg_warning(no_warn);
	EXEC SQL CONNECT TO default;

	EXEC SQL BEGIN TRANSACTION;

	stderr.len = (int)(4096 - (sp - stderr.arr));

	EXEC SQL INSERT INTO setcore.fault_flow_call(
		schema_name,
		call_name,
		blob,
		exit_class,
		exit_status,
		signal
	  ) VALUES (
		:schema_name,
		:call_name,
		:blob::udig,
		:exit_class,
		:exit_status::setcore.uni_xstatus,
		:signal::setcore.xdr_signal
	  )
  	  ON CONFLICT
  		DO NOTHING
	;
	EXEC SQL INSERT INTO setcore.fault_flow_call_stderr(
		schema_name,
		call_name,
		blob,
		stderr
	  ) VALUES (
		:schema_name,
		:call_name,
		:blob,
		:stderr
	  )
  	  ON CONFLICT
  		DO NOTHING
	;
	EXEC SQL END TRANSACTION;

	_exit(EXIT_OK);
}
