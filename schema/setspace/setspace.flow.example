#
#  Synopsis:
#	Flow blobs into setspace database schema
#  Usage:
#  	flowd server setspace.conf
#  See:
#  	schema.sql
#

boot
{
	brr_capacity = 256;
	flow_worker_count = 16;
	os_exec_worker_count = 12;
	os_exec_capacity = 12;

	xdr_roll_duration = "24h";
	fdr_roll_duration = "24h";
	qdr_roll_duration = "24h";

	heartbeat_duration = "10s";
}

tail biod
{
	#  the dir blobio/ must be symbolic link for tail to work
	path = "spool/blobio/biod.brr";
}

sql database setspace
{
	driver_name = "postgres";
	data_source_name = "sslmode=disable";
	max_idle_conns = 1;
	max_open_conns = 64;
}

#
#  Synopsis:
#	Is the blob in the service table
#
sql query in_service_table row
{
	database is setspace;

	result row is (
		answer bool
	);

	statement = `

	SELECT exists (
	  select
		blob
	    from
		setspace.service
	    where
		blob = $1::udig
	);

	`;
}

command brr_on_network
{
	path = "true";
}

command brr_off_network
{
	path = "true";
}

sql exec merge_service
{
	database is setspace;

	statement = `

	INSERT into setspace.service(
		blob
	  ) VALUES(
	  	$1::udig
	  ) ON CONFLICT
	  	do nothing
	;

	`;
}

call brr_off_network()
  when
	(
		biod.chat_history == "no"
		and
		(
			biod.verb == "eat"
			or
			biod.verb == "get"
		)
	)
	or
	(
		biod.verb == "take"
		and
		biod.chat_history == "ok,ok,ok"
	)
;

call brr_on_network()
  when
  (
        (
		biod.verb == "put"
		or
		biod.verb == "get"
		or
		biod.verb == "eat"
		or
		biod.verb == "wrap"
		or
		biod.verb == "roll"
	)
	and
	biod.chat_history == "ok"
  ) or (
	biod.verb == "give"
	and
	biod.chat_history == "ok,ok"
  )
;

query in_service_table(biod.udig);

#
#  Synopsis:
#	Delete zombies
#
command is_zombie_alive
{
	#  typically in $SETSPACE_ROOT/sbin

	path = "eat-blob";
	exit_status is OK when in {0, 1};
}

sql exec delete_blob
{
	statement = `

	DELETE from
	  	setspace.service
	  WHERE
	  	blob = $1::udig
	;
	
	`;

	database is setspace;
}

call is_zombie_alive(biod.udig)
  when
	#
	#  brr record says blob does not exist.
	#
  	brr_off_network.exit_status == 0
	and

	#
	#  Database thinks blob does exist.
	#
	in_service_table.answer == true
;

query delete_blob(biod.udig)
  when
  	is_zombie_alive.exit_status == 1
;

query merge_service(biod.udig)
  when
  	brr_on_network.exit_status == 0
	and
	in_service_table.answer == false
;

#
#  Synopsis:
#	Populate byte_count table
#
sql query in_byte_count_table row
{
	database is setspace;

	result row is (
		answer bool
	);

	statement = `

	SELECT exists (
	  select
		blob
	    from
		setspace.byte_count
	    where
		blob = $1::udig
	);

	`;
}

command merge_byte_count
{
	path = "sbin/merge-byte_count";
	exit_status is OK when in {0, 1};
}

query in_byte_count_table(biod.udig)
  when
  	in_service_table.answer == true
	or
	merge_service.rows_affected == 1
;

call merge_byte_count(biod.udig)
  when
  	in_byte_count_table.answer == false
;

#
#  Synopsis:
#	Populate byte_bitmap table
#
sql query in_byte_bitmap_table row
{
	database is setspace;

	result row is (
		answer bool
	);

	statement = `

	SELECT exists (
	  select
		blob
	    from
		setspace.byte_bitmap
	    where
		blob = $1::udig
	);
	
	`;
}

command merge_byte_bitmap
{
	path = "sbin/merge-byte_bitmap";
	exit_status is OK when in {0, 1};
}

query in_byte_bitmap_table(biod.udig)
  when
  	in_service_table.answer == true
	or
	merge_service.rows_affected == 1
;

call merge_byte_bitmap(biod.udig)
  when
  	in_byte_bitmap_table.answer == false
;

#
#  Synopsis:
#	Is in utf8 well formed table.
#  Note:
#	Need to first consult byte_bitmap for forbidden utf8 bytes.
#	is 0xff the only forbidden utf8 byte?
#
sql query in_is_utf8wf_table row
{
	database is setspace;

	result row is (
		answer	bool,
		is_utf8	bool
	);

	statement = `

	SELECT
	  exists (
	    select
		blob
	      from
		setspace.is_utf8wf
	      where
		blob = $1::udig
	  ),
	 (
	    select
	  	is_utf8
	      from
	    	setspace.is_utf8wf
	      where
	    	blob = $1::udig
	 );

	  `;
}

command get_is_utf8wf
{
	path = "sbin/get-is-utf8wf";
	exit_status is OK when in {
		0,			#  is well formed utf8
		1,			#  not well formed utf8
		2,			#  empty blob,
		3			#  blob does not exist
	};
}

sql query merge_is_utf8wf row
{
	#  Note: does the insert return a value upon conflict?
	statement = `

	INSERT into setspace.is_utf8wf(
		blob,
		is_utf8
	  ) SELECT
		$1::udig,
		case $2 
	  		when '0' then true
	  		when '1' then false
	  		when '2' then false
		end
  	  ON CONFLICT
  		do nothing
  	  RETURNING
  		is_utf8
	;

	`;
	
	result row is (
		is_utf8 bool
	);

	database is setspace;
}

query in_is_utf8wf_table(biod.udig)
  when
  	in_service_table.answer == true
	or
	merge_service.rows_affected == 1
;

#  does the blob contain the char 0xff?

sql query has_char_0xff row {
	
	statement = `
	
	SELECT
		(bm.bitmap & char_0xff) != all_zero
	  FROM
	  	setspace.byte_bitmap bm,

		--  all zero bits
		coalesce(
			B'0'::bit(256)
		) as all_zero,

		coalesce(
			B'1'::bit(256)
		) as char_0xff
	  where
	  	bm.blob = $1::udig
	;
	
	`;
	result row is (
		answer bool
	);
	database is setspace;
}

command service_exists
{
	path = "true";
	exit_status is OK when in {0, 1};
}

call service_exists(biod.udig)
  when
  	merge_service.rows_affected == 1
	or
	in_service_table.answer == true
;

query has_char_0xff(biod.udig)
  when
	service_exists.exit_status == 0
;

call get_is_utf8wf(biod.udig)
  when
	has_char_0xff.answer == false
	and
	in_is_utf8wf_table.answer == false
;

sql exec merge_is_utf8wf_not
{
	statement = `
	insert into setspace.is_utf8wf(
		blob,
		is_utf8
	) values (
		$1::udig,
		false
	) on conflict
		do nothing
	`;
	database is setspace;
}

#  blob not utf8 when 0xff char exists
query merge_is_utf8wf_not(biod.udig)
  when
  	has_char_0xff.answer == true
	and
	in_is_utf8wf_table.answer == false
;

query merge_is_utf8wf(biod.udig, get_is_utf8wf.exit_status)
  when
  	get_is_utf8wf.exit_status == 0
	or
	get_is_utf8wf.exit_status == 1
	or
	get_is_utf8wf.exit_status == 2		#  merge empty blob
;

#
#  Synopsis:
#	Populate byte_prefix_32 table
#
sql query in_byte_prefix_32_table row
{
	database is setspace;

	result row is (
		answer bool
	);

	statement = `

	SELECT exists (
	  select
		blob
	    from
		setspace.byte_prefix_32
	    where
		blob = $1::udig
	);
	
	`;
}

command merge_byte_prefix_32
{
	path = "sbin/merge-byte_prefix_32";
	exit_status is OK when in {0, 1};
}

query in_byte_prefix_32_table(biod.udig)
  when
  	in_service_table.answer == true
	or
	merge_service.rows_affected == 1
;

call merge_byte_prefix_32(biod.udig)
  when
  	in_byte_prefix_32_table.answer == false
;

#  typically printable unix ascii file plus space, tab and new line characters.
#  control-r is excluded (which would be is_printable_dos).
#
#  Note: perhaps a view 'is_printable_unix'

sql query is_printable_unix row
{
	statement = `

	SELECT
		--  no non-ascii chars
		bm.bitmap::bit(128) = B'0'::bit(128)

		--  length > 0
		and
		bm.bitmap != all_zero
		and
		(forbidden_control & bm.bitmap) = all_zero
	  FROM
		setspace.byte_bitmap bm,

		--  all zero bits
		coalesce(
			B'0'::bit(256)
		) as all_zero,

		--  forbidden chars in typical printable ascii unix file
		--  notice tab and newline are not forbidden.

		coalesce(
		  --  first 9 control characters: decimal 0-8: NUL -> BS
		  (B'1111111111'::bit(256) >> 247)		|

		  --  21 control chars  - decimal 11-31: VT -> US
		  (B'111111111111111111111'::bit(256) >> 224)	|

		  --  del char - decimal 127
		  (B'1'::bit(256) >> 128)
		) as forbidden_control
	  WHERE
		bm.blob = $1::udig
	;`;

	result row is (
		answer bool
	);

	database is setspace;
}

query is_printable_unix(biod.udig)
  when
	(
		in_is_utf8wf_table.is_utf8 == true
		or
		merge_is_utf8wf.is_utf8 == true
	)
	and
	(
		in_byte_bitmap_table.answer == true
		or
		merge_byte_bitmap.exit_status == 0
	)
;

sql query is_drblob row
{
	statement = `

	SELECT
		--  all required chars
		(required_char & bm.bitmap) = required_char

		--  no forbidden chars
		and
		(forbidden_char & bm.bitmap) = all_zero
		and

		--  and time stamp
		escaped_prefix ~ (
			-- century/year
			'^[234][0-9]{3}-'			||

			--  month
			'[01][0-9]-'				||

			--  day
			'[0123][0-9]'				||

			-- hour
			'T[012][0-9]:'				||

			-- minute
			'[0-6][0-9]:'				||

			-- second
			'[0-6][0-9]'				||

			-- nanosecond
			-- is the fractional part required?
			'[.][0-9]{1,9}'				||

			--  timezone.
			--  Note: still not sure if Z alone indicates GMT
			--  	  or unknown
			'[+-Z]'
		)
	  FROM
		setspace.byte_prefix_32 p32
		  natural join setspace.byte_bitmap bm,
		  lateral encode(p32.prefix, 'escape') escaped_prefix,

		  --  all of these chars must be in any drblob tuple
		  coalesce(
			--  new-line character - decimal 10
			(B'1'::bit(256) >> 245)		|

			--  tab character
			(B'1'::bit(256) >> 246)

		  ) as required_char,

		  -- forbidden chars in drblob tuple
		  coalesce(
			--  space character
			(B'1'::bit(256) >> 224)

		  ) as forbidden_char,

		  --  all zero bits
		  coalesce(
			  (B'0'::bit(256))
		  ) as all_zero
	  WHERE
		 p32.blob = $1::udig
	`;
	result row is (
		answer bool
	);
	database is setspace;
}

query is_drblob(biod.udig)
  when
  	is_printable_unix.answer == true
;

command append_drblob_brr
{
	path = "append-brr";
	argv = (
		"../drblob/spool/setspace.brr"
	);
}

call append_drblob_brr(
	biod.start_time,
	biod.netflow,
	biod.verb,
	biod.udig,
	biod.chat_history,
	biod.blob_size,
	biod.wall_duration
) when
	is_drblob.answer == true
	and
	(
		in_byte_prefix_32_table.answer == true
		or
		merge_byte_prefix_32.exit_status == 0
	)
;

sql query in_new_line_count_table row
{
	statement = `

	SELECT exists (
	  select
	  	blob
	    from
	    	setspace.new_line_count
	    where
	    	blob = $1::udig
	);

	`;

	result row is (
		answer bool
	);

	database is setspace;
}

query in_new_line_count_table(biod.udig)
  when
  	in_is_utf8wf_table.is_utf8 == true
;

command merge_new_line_count
{
	path = "merge-new_line_count";
}

call merge_new_line_count(biod.udig)
  when
  	in_new_line_count_table.answer == false
;

#
#  Synopsis:
#	Is in is_udigish table.
#
sql query in_is_udigish_table row
{
	database is setspace;

	result row is (
		answer	bool,
		udigish	bool
	);

	statement = `

	SELECT
	  exists (
	    select
		blob
	      from
		setspace.is_udigish
	      where
		blob = $1::udig
	  ),
	 (
	    select
	  	udigish
	      from
	    	setspace.is_udigish
	      where
	    	blob = $1::udig
	 );

	  `;
}

sql exec merge_is_udigish
{
	#  Note: does the insert return a value upon conflict?
	statement = `

	INSERT into setspace.is_udigish(
		blob,
		udigish
	  ) SELECT
		$1::udig,
		case $2 
	  		when '0' then true
	  		when '1' then false
	  		when '2' then false
		end
  	  ON CONFLICT
  		do nothing
	;

	`;
	
	database is setspace;
}

#  check that a known utf8 blob is also in is_udigish

query in_is_udigish_table(biod.udig)
  when
	(
		in_is_utf8wf_table.answer == true
		and
		in_is_utf8wf_table.is_utf8 == true
	)
	or
	merge_is_utf8wf.is_utf8 == true
;

command get_is_udigish
{
	path = "sbin/get-bool-command";
	argv = (
		"is-udigish"
	);
	exit_status is OK when in {
		0,			#  command is true
		1,			#  command is false
		2,			#  empty blob,
		3			#  blob does not exist
	};
}

call get_is_udigish(biod.udig)
  when
	in_is_udigish_table.answer == false
;

query merge_is_udigish(biod.udig, get_is_udigish.exit_status)
  when
  	get_is_udigish.exit_status == 0
	or
	get_is_udigish.exit_status == 1
	or
	get_is_udigish.exit_status == 2		#  merge empty blob
;

#
#  Synopsis:
#	Is in has_byte_json_bracket table.
#
sql query in_has_byte_json_bracket_table row
{
	database is setspace;

	result row is (
		answer	bool,
		has_bracket bool
	);

	statement = `

	SELECT
	  exists (
	    select
		blob
	      from
		setspace.has_byte_json_bracket
	      where
		blob = $1::udig
	  ),
	 (
	    select
	  	has_bracket
	      from
	    	setspace.has_byte_json_bracket
	      where
	    	blob = $1::udig
	 );

	  `;
}

sql exec merge_has_byte_json_bracket
{
	#  Note: does the insert return a value upon conflict?
	statement = `

	INSERT into setspace.has_byte_json_bracket(
		blob,
		has_bracket
	  ) SELECT
		$1::udig,
		case $2 
	  		when '0' then true
	  		when '1' then false
	  		when '2' then false
		end
  	  ON CONFLICT
  		do nothing
	;

	`;
	
	database is setspace;
}

#  check that a known utf8 blob is also in has_byte_json_bracket

query in_has_byte_json_bracket_table(biod.udig)
  when
	(
		in_is_utf8wf_table.answer == true
		and
		in_is_utf8wf_table.is_utf8 == true
	)
	or
	merge_is_utf8wf.is_utf8 == true
;

command get_has_byte_json_bracket
{
	path = "sbin/get-bool-command";
	argv = (
		"has-byte-json-bracket"
	);
	exit_status is OK when in {
		0,			#  command is true
		1,			#  command is false
		2,			#  empty blob,
		3			#  blob does not exist
	};
}

call get_has_byte_json_bracket(biod.udig)
  when
	in_has_byte_json_bracket_table.answer == false
;

query merge_has_byte_json_bracket(
	biod.udig,
	get_has_byte_json_bracket.exit_status
) when
  	get_has_byte_json_bracket.exit_status == 0
	or
	get_has_byte_json_bracket.exit_status == 1
;

command append_jsonorg_brr
{
	path = "append-brr";
	argv = (
		"../jsonorg/spool/setspace.brr"
	);
}

call append_jsonorg_brr(
	biod.start_time,
	biod.netflow,
	biod.verb,
	biod.udig,
	biod.chat_history,
	biod.blob_size,
	biod.wall_duration
) when
	in_has_byte_json_bracket_table.answer == true
	or
	merge_has_byte_json_bracket.rows_affected == 1
;
