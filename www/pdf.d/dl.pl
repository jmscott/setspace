#
#  Synopsis:
#	Build an html <dl> results set of pdf files that match a keyword search.
#  Note:
#	Don't underestimate the subtlely of this script.  Folding the many
#	branches of queries together ain't easy.
#
#  	Why don't complex scripts have companion scripts that generate legends?
#	For example, html output like <spam class="null">Unknown</span>
#	would typically be color coded to indicate null.  Shouldn't
#	a color bar or legend script exist that indicates the meaning of the
#	colors?  Might this legend be automatically generated by the defining
#	*.cgi files.
#
#	Discovery time is not a total order;  need to tack on blob at end
#	of order by clause in OBY2SQL_SEARCH_ORDER_BY.
#

#
#  High resolution of query execution time.
#  In principle, this logging ought to be elsewhere.
#
use Time::HiRes;

require 'dbi.pl';
require 'blob.pl';
require 'pdf.d/query.pl';
require 'account.d/common.pl';
require 'epoch2english.pl';

select STDOUT;  $| = 1;

our %QUERY_ARG;

#
#  You must be logged in to see your documents;  otherwise, return nothing.
#
#  Security issues such as these will eventually be pushed to the httpd2 layer
#  or, preferably, to the database view level using row level security.
#  Or both.
#
my $pg_role = cookie2pg_role();
return 1 unless $pg_role;

#
#  Two components of the query are constructed.
#
#  The first level, a common table expression named 'search', finds and limits 
#  the document results subset in pdfinfo, possibly doing text searches and 
#  rankings against variations on the document title and body of the document
#  stored in the pdftotext table.
#
#  The second level, a simpler outer table, joins the limited results subset
#  against various tables used in display of details of the document.
#  Typically the results set should be bounded on the order of 20-100 elements.
#

#
#  Target list for Order by qualifications with no keyword query
#
use constant OBY2SQL_SEARCH_TARGET =>
{
	dtimd	=>	q(
			,extract(epoch from now() - b.discover_time)
				as "discover_elapsed",
			b.discover_time
),
	#
	#  Same as dtimed
	#
	dtima	=>	q(
			,extract(epoch from now() - b.discover_time)
				as "discover_elapsed",
			b.discover_time
),
	'pgcoa' =>	',pc.value as pdfinfo_pages',
	'pgcod' =>	',pc.value as pdfinfo_pages',
};

use constant OBY2SQL_SEARCH_FROM =>
{
	pgcoa =>	'left outer join pdfinfo_pages pc on (p.blob =pc.blob)',
	pgcod =>	'left outer join pdfinfo_pages pc on (p.blob = pc.blob)'
};

use constant OBY2SQL_SEARCH_WHERE =>
{
	pgcoa =>	'and pc.value is not null',
	pgcod =>	'and pc.value is not null',
};

use constant OBY2SQL_SEARCH_ORDER_BY =>
{
	dtimd =>	'b.discover_time desc',
	dtima =>	'b.discover_time asc',

	pgcoa =>	'pc.value asc, b.discover_time desc',
	pgcod =>	'pc.value desc, b.discover_time desc',

	rand =>		'random()'
};

#
#  Target list for Order by qualifications with keyword query
#
use constant OBY2SQL_TARGET =>
{
	dtimd =>	',pc.value as pdfinfo_pages',
	dtima =>	',pc.value as pdfinfo_pages',

	pgcoa	=>	q(
	      ,extract(epoch from now() - b.discover_time) as "discover_elapsed"
	),
	pgcod	=>	q(
	      ,extract(epoch from now() - b.discover_time) as "discover_elapsed"
	),
	rand	=>	q(
	      ,extract(epoch from now() - b.discover_time) as "discover_elapsed"
			,pc.value as pdfinfo_pages
	)
};

use constant OBY2SQL_FROM =>
{
	dtima =>	'left outer join pdfinfo_pages pc on (s.blob =pc.blob)',
	dtimd =>	'left outer join pdfinfo_pages pc on (s.blob =pc.blob)',

	pgcod =>	'inner join blob b on (b.id = s.blob)',
	pgcoa =>	'inner join blob b on (b.id = s.blob)',

	rand	=>	q(
			inner join blob b on (b.id = s.blob)
			left outer join pdfinfo_pages pc on (
				s.blob = pc.blob
			)
	),
};

use constant OBY2SQL_ORDER_BY =>
{
	dtima	=>	's.discover_time asc',
	dtimd	=>	's.discover_time desc',
	
	pgcoa =>	's.pdfinfo_pages asc, b.discover_time desc',
	pgcod =>	's.pdfinfo_pages desc, b.discover_time desc',

	#
	#  We must reorder the parent CTE subset since no order is assumed.
	#
	#  Note:
	#	Hmmm, adding random() as a secondary order raising an
	#	interesting question.  Ommiting an order is inherently 
	#	different than ordering by random().  Adding an extra
	#	random() seems reasonable, since the resulting CTE is
	#	just a set.
	#
	rand	=>	'random()'
};

#
#  SQL Constants used by text search, start with Q_OBY
#
use constant B_OBY2SQL_DISCOVER_TARGET => q(
	,extract(epoch from now() - b.discover_time) as "discover_elapsed",
			b.discover_time,
			q
);

#
#  Target list for Order by qualifications with keyword query
#
use constant Q_OBY2SQL_SEARCH_TARGET =>
{
	tscd	=>	q(
			,greatest(
				ts_rank_cd(pit.value_tsv, q, 32),
				ts_rank_cd(ptt.value, q, 2 | 32),
				ts_rank_cd(mt.value_tsv, q, 32),
				ts_rank_cd(t.value_tsv, q, 32)
			) as ts_rank_cd,
			greatest(
				ts_rank_cd(pit.value_tsv, q, 32),
				ts_rank_cd(mt.value_tsv, q, 32),
				ts_rank_cd(t.value_tsv, q, 32)
			) >= ts_rank_cd(ptt.value, q, 2 | 32)
				as "ts_title_ranked",
			q
	),

	dtimd	=>	B_OBY2SQL_DISCOVER_TARGET,
	dtima	=>	B_OBY2SQL_DISCOVER_TARGET,
	pgcoa =>	',pc.value as pdfinfo_pages, q',
	pgcod =>	',pc.value as pdfinfo_pages, q',
	rand =>		',q'
};

use constant Q_OBY2SQL_SEARCH_TSCD_FROM => q(

			  left outer join pdfinfo_title pit on (
			  	p.blob = pit.blob
			  )
			  left outer join pdftotext_readable_tsv ptt on (
			  	p.blob = ptt.pdf_blob
			  )
			  left outer join title t on (
			  	p.blob = t.blob
			  )
			  left outer join my_title mt on (
				p.blob = mt.blob
				and
				mt.pg_role = '${pg_role}'
			  ),
			ts_rewrite(
			  plainto_tsquery('english', E'${ts_q}'),
				  'dummy_word', 'dummy_word'
			) as q
);

use constant Q_OBY2SQL_SEARCH_FROM =>
{
	tscd =>		Q_OBY2SQL_SEARCH_TSCD_FROM,

	dtimd =>	Q_OBY2SQL_SEARCH_TSCD_FROM,

	dtima =>	Q_OBY2SQL_SEARCH_TSCD_FROM,

	pgcoa =>	'left outer join pdfinfo_pages pc on (p.blob =pc.blob)'.
			Q_OBY2SQL_SEARCH_TSCD_FROM,

	pgcod =>	'left outer join pdfinfo_pages pc on (p.blob =pc.blob)'.
			Q_OBY2SQL_SEARCH_TSCD_FROM,
	rand =>		Q_OBY2SQL_SEARCH_TSCD_FROM,
};

use constant Q_OBY2SQL_SEARCH_TSCD_WHERE => q(
			and
			(
				pit.value_tsv @@ q
				or
				ptt.value @@ q
				or
				mt.value_tsv @@ q
				or
				t.value @@ q
			)
);

use constant Q_OBY2SQL_SEARCH_WHERE =>
{
	tscd =>		Q_OBY2SQL_SEARCH_TSCD_WHERE,
	dtima =>	Q_OBY2SQL_SEARCH_TSCD_WHERE,
	dtimd =>	Q_OBY2SQL_SEARCH_TSCD_WHERE,
	pgcoa =>	'and pc.value is not null' .
				Q_OBY2SQL_SEARCH_TSCD_WHERE,
	pgcod =>	'and pc.value is not null' .
				Q_OBY2SQL_SEARCH_TSCD_WHERE,
	rand =>		Q_OBY2SQL_SEARCH_TSCD_WHERE,
};

use constant Q_OBY2SQL_SEARCH_ORDER_BY =>
{
	tscd =>		'ts_rank_cd desc, b.discover_time desc',
	dtimd =>	'b.discover_time desc',
	dtima =>	'b.discover_time asc',

	pgcoa =>	'pc.value asc, b.discover_time desc',
	pgcod =>	'pc.value desc, b.discover_time desc',

	rand =>		'random()'
};


use constant Q_OBY2SQL_HEADLINE_TARGET => q(
			,ts_headline(
				'english',
				pr.value,
				s.q,
				'StartSel=${StartSel},StopSel=${StopSel}'
				) as "pdftotext_headline",
			pr.text_blob as "pdftotext_blob"
);

#
#  Target list for Order by qualifications with keyword query
#
use constant Q_OBY2SQL_TARGET =>
{
	tscd =>		Q_OBY2SQL_HEADLINE_TARGET .
			  B_OBY2SQL_DISCOVER_TARGET .
			  ',pc.value as pdfinfo_pages',

	dtimd =>	Q_OBY2SQL_HEADLINE_TARGET .
			  ',pc.value as pdfinfo_pages',
	dtima =>	Q_OBY2SQL_HEADLINE_TARGET .
			  ',pc.value as pdfinfo_pages',

	pgcoa	=>	Q_OBY2SQL_HEADLINE_TARGET .
			  B_OBY2SQL_DISCOVER_TARGET,
	pgcod	=>	Q_OBY2SQL_HEADLINE_TARGET .
			  B_OBY2SQL_DISCOVER_TARGET,

	rand	=>	Q_OBY2SQL_HEADLINE_TARGET .
			  B_OBY2SQL_DISCOVER_TARGET .
			  ',pc.value as pdfinfo_pages'
};

use constant TS_SQL_FROM => q(
			inner join blob b on (s.blob = b.id)
			left outer join pdfinfo_pages pc on (
				s.blob = pc.blob
			)
			left outer join pdftotext_readable pr on (
				s.blob = pr.pdf_blob
			)
);

use constant SQL_DTIM_FROM => q(
				left outer join pdftotext_readable pr on (
					s.blob = pr.pdf_blob
				)
				left outer join pdfinfo_pages pc on (
					s.blob = pc.blob
				)
);

use constant SQL_PGCO_FROM => q(
				inner join blob b on (b.id = s.blob)
				left outer join pdftotext_readable pr on (
					s.blob = pr.pdf_blob
				)
);

use constant Q_OBY2SQL_FROM =>
{
	tscd =>		TS_SQL_FROM,

	dtima =>	SQL_DTIM_FROM,
	dtimd =>	SQL_DTIM_FROM,

	pgcod =>	SQL_PGCO_FROM,
	pgcoa =>	SQL_PGCO_FROM,

	rand	=>	TS_SQL_FROM,
};

use constant Q_OBY2SQL_ORDER_BY =>
{
	tscd =>		's.ts_rank_cd desc, b.discover_time desc',
	dtima =>	's.discover_time asc',
	dtimd =>	's.discover_time desc',
	
	pgcoa =>	's.pdfinfo_pages asc, b.discover_time desc',
	pgcod =>	's.pdfinfo_pages desc, b.discover_time desc',

	#
	#  We must reorder the parent CTE subset since no order is assumed.
	#
	#  Note:
	#	Hmmm, adding random() as a secondary order raises an
	#	interesting question.  Ommiting an order is inherently 
	#	different than ordering by random().  Adding an extra
	#	random() seems reasonable, since the resulting CTE is
	#	just a set.
	#
	rand	=>	'random()'
};

#
#  Delimit keyword matches in ts_headline() with magical, random
#  strings, to drasticaly reduce the probablity the the magic delimiter
#  string is not in the data stream.
#
my $rand = sprintf('%06d', int(rand(999999)));
my (
	$StartSel,
	$StopSel,
) = (
	's1' . $rand,
	's2' . $rand,
);

#
#  Query arguments passed on uri.
#
my (
	$q,
	$page,
	$rppg,
	$oby,
) = (
	$QUERY_ARG{q},
	$QUERY_ARG{page},
	$QUERY_ARG{rppg},
	$QUERY_ARG{oby},
);

my $q_norm;

#
#  Parse text query.  If requests wants to sorting by tscd with no text
#  qualification then return empty list ... not sure if that is correct
#  behavior ... wouldn't a secondary sort order exist?
# 
my $ts_q;
if ($ts_q = $q) {
	$ts_q =~ s/\\/\\\\/g;
	$ts_q =~ s/'/\\'/g;
}

$oby = 'dtimd' if $oby eq 'tscd' and length($q) == 0;

my $start_time = Time::HiRes::gettimeofday();

#
#  Opening <dl class="..." id="...">
#
print <<END;
<dl$QUERY_ARG{class_att}$QUERY_ARG{id_att}>
END

my $offset = ($page - 1) * $rppg;

my (
	$sql_search_target,
	$sql_search_from,
	$sql_search_where,
	$sql_search_order_by,
	$sql_target,
	$sql_from,
	$sql_order_by,
);

if ($ts_q) {
	$sql_search_target = Q_OBY2SQL_SEARCH_TARGET->{$oby};
	$sql_search_from = Q_OBY2SQL_SEARCH_FROM->{$oby};
	$sql_search_from =~ s/\${ts_q}/$ts_q/gsm;
	$sql_search_where = Q_OBY2SQL_SEARCH_WHERE->{$oby};
	$sql_search_order_by = Q_OBY2SQL_SEARCH_ORDER_BY->{$oby};

	$sql_target = Q_OBY2SQL_TARGET->{$oby};
	$sql_target =~ s/\${StartSel}/$StartSel/gsm;
	$sql_target =~ s/\${StopSel}/$StopSel/gsm;
	$sql_from = Q_OBY2SQL_FROM->{$oby};
	$sql_order_by = Q_OBY2SQL_ORDER_BY->{$oby};
} else {
	$sql_search_target = OBY2SQL_SEARCH_TARGET->{$oby};
	$sql_search_from = OBY2SQL_SEARCH_FROM->{$oby};
	$sql_search_where = OBY2SQL_SEARCH_WHERE->{$oby};
	$sql_search_order_by = OBY2SQL_SEARCH_ORDER_BY->{$oby};

	$sql_target = OBY2SQL_TARGET->{$oby};
	$sql_from = OBY2SQL_FROM->{$oby};
	$sql_order_by = OBY2SQL_ORDER_BY->{$oby};
}
$sql_from =~ s/\${pg_role}/$pg_role/gsm;
$sql_search_from =~ s/\${pg_role}/$pg_role/gsm;

my $Q = dbi_select(
	db	=>	dbi_connect(),
	tag	=>	'pdf-dl',
	#dump	=>	'>/tmp/pdf-dl.sql',
	#trace	=>	15,
	sql	=>	<<END
/*
 *  Table is composed of search results in common table expression joined
 *  to detail for each matching blob.
 *
 *  Outer CTE: locates pagefull of pdfs that match keywords.
 */	
with search as (
  select
	p.blob				/* blob in pdfinfo table */
	$sql_search_target
  from
	/*
	 *  Only files with a reasonable pdfinfo.
	 */
	pdfinfo p
	  /*
	   *  Least significant order by clause is always
	   *  blob.discover_time desc.
	   */
	  inner join blob b on (b.id = p.blob)
	  $sql_search_from
  where
  	true
  	$sql_search_where
  order by
  	$sql_search_order_by
  limit
  	$rppg
  offset
  	$offset
)
/*
 *  Query Detail: join the limited results set against displayed details.
 */
select
	s.*,
	coalesce(
		mt.value,		/* my title */
		t.value,		/* public title */
		pit.value		/* pdfinfo_title */
	) as "title"
	$sql_target
    from
	search s
	  $sql_from
	  left outer join pdfinfo_title pit on (s.blob = pit.blob)
	  left outer join my_title mt on (
	  	s.blob = mt.blob
		and
		mt.pg_role = '$pg_role'
	  )
	  left outer join title t on (s.blob = t.blob)
    order by
	$sql_order_by
;
END
);

#
#  Put the results set as <dt><dd> like
#
#  	<dt>Title</dt>
#  	<dd>
#  	  Page Count:
#	  Discovered:
#
my $ts_headline_english_cache_twig;
while (my $r = $Q->fetchrow_hashref()) {
	my (
		$blob,
		$discover_elapsed,
		$pdftotext_headline,
		$title,
		$pdfinfo_pages,
		$ts_rank_cd,
		$ts_title_ranked,
		$pdftotext_blob,
	) = (
		encode_html_entities($r->{blob}),
		$r->{discover_elapsed},
		$r->{pdftotext_headline},
		encode_html_entities($r->{title}),
		$r->{pdfinfo_pages},
		$r->{ts_rank_cd},
		$r->{ts_title_ranked},
		$r->{pdftotext_blob},
		$r->{q},
	);
	#
	#  Stash the normalized version of the query.
	#
	$q_norm = $r->{q} unless $q_norm;

	$pdfinfo_pages = '<span class="null">Unknown</span>'
					unless $pdfinfo_pages;

	#
	#  My Blob Title, then PDF Info Title, then Headline, then UDIG.
	#
	my $title_text;
	unless ($title_text = $title) {
		unless ($title_text = $blob) {
			die 'impossible: no udig for blob';
		}
	}
	my $a_title_att = $title_text;
	$title_text = "<code>$title_text</code>" if $title_text eq $blob;
	my $a_title =<<END;
<a
	title="View: $a_title_att"
	href="/cgi-bin/pdf?out=blob&amp;udig=$blob"
>$title_text</a>
END
	#
	#  Escape the random, keyword delimiters in pdftotext_headline that were
	#  injected by ts_headline() during query.
	#
	my $span_headline;
	if (my $headline = encode_html_entities($pdftotext_headline)) {
		#
		#  Replace random ints with span[@class=keyword]
		#
		$headline =~ s/$StartSel/<span class="keyword">/g;
		$headline =~ s/$StopSel/<\/span>/g;
		$span_headline =<<END;
 <span class="headline">$headline</span>
END
		#
		#  Log the headline for a possible cache.
		#
		$ts_headline_english_cache_twig .=<<END;
 <answer>
  <blob>@{[text2xml($pdftotext_blob)]}</blob>
  <headline>@{[text2xml($headline)]}</headline>
 </answer>
END
	}

	my $discovered_text = epoch2english(
					elapsed =>	$discover_elapsed,
					past	=>	'ago',
					terse	=>	'yes'
				);
	print <<END;
<dt>
 $a_title
</dt>
<dd>
 $span_headline
 <div class="meta">

  <div class="field page-count">
   <span class="title">Page Count:</span>
   <span class="data">$pdfinfo_pages</span>
  </div>

  <div class="field discovered">
   <span class="title">Discovered:</span>
   <span class="data">$discovered_text</span>
  </div>

  <a
	class="detail"
  	title="Detail of Blob: $blob"
  	href="/blob-detail.shtml?udig=$blob"
  ><span>Detail</span></a>

 </div>
</dd>
END
}

print <<END;
</dl>
END

#
#  Tack on a <note> of elapsed time and the rewritten ts query
#
my $elapsed = sprintf('%.4f', Time::HiRes::gettimeofday() - $start_time);
my $note_text =<<END;
Elapsed Time: $elapsed
     PG Role: $pg_role
END

cgi2blob(
	extra	=>	<<END
<ts-headline-english-cache>
 <query>@{[text2xml($q_norm)]}</query>
 $ts_headline_english_cache_twig
</ts-headline-english-cache>
 <note>
$note_text
 </note>
END
);

1;
