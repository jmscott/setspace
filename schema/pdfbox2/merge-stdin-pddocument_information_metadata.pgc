/*
 *  Synopsis:
 *  	Merge the output of the putPDDocumentInformation into the database
 *  Usage:
 *	merge-stdin-file 
 *  Arguments:
 *  	1	udig of the blob that file command analyzed
 *	2	exit status of java putPDDocumentInformation.class
 *  	3	number of bytes to read on the standard input
 *  Exit Status:
 *  	0	ok, tuple was merged
 *  	1	wrong number of arguments
 *  	2	can not parse input blob size
 *  	3	malloc() of input blob buffer failed
 *	4	read() of standard input failed
 *	5	syntax error on udig
 *	6	sql error
 *	7	sql warning
 *	8	input field blob too small
 *	9	input field blob too large
 *	10	syntax error on input blob
 *  See:
 *	putPDDocumentInformation.java
 *  Note:
 *	Is VARCHAR truly allocated in characters (not bytes)?
 *
 *	The syntax of the field file is assumed to be correct.
 *	Probably ought to add at least a few inexpensive tests.
 *
 *	To the output consider framing the headers with Begin/End.
 *
 *		Begin:
 *		Title: ...
 *		...
 *		End:
 */

static char progname[] = "merge-stdin-pddocument_information_metadata";

#define EXIT_OK		0
#define EXIT_BAD_ARGC	1
#define EXIT_BAD_SIZE	2
#define EXIT_BAD_MALLOC 3
#define EXIT_BAD_READ	4
#define EXIT_BAD_UDIG	5
#define EXIT_SQLERROR	6
#define EXIT_SQLWARN	7
#define EXIT_BLOB_SMALL 8
#define EXIT_BLOB_BIG	9

#define COMMON_NEED_READ_BLOB
#include "../../common.c"

#define COMMON_ECPG_NEED_SQL_WARNING
#define COMMON_ECPG_NEED_SQL_ERROR
#include "../../common-ecpg.c"

#include <stdlib.h>

static struct _ecpg_sql_state_fault no_warn[] =
{
        {"02000", 0},                //  no data for conflict on upsert/insert
        {(char *)0, 0}
};

static char *input = NULL;
static char *input_limit = NULL;

/*
 *  Scan a field name.  Code depends upon syntacically correct fields file
 *  generated by putPDDocumentInformation.  An incorrect file format could
 *  cause memory corruption.
 *
 */

static void
scan(
	char key[256],
	char value[32768]
) {
	char *p, *q;
	static char nk[] = "scan input: key";
	static char nv[] = "scan input: value";

	p = input;
	q = key;

	while (*p) {
		char c;

		c = *p++;
		if (c == 0 || c == '\n')
			die2(10, nk, "unexpected null or new-line");
		if (c == ':') {

			//  saw end of field name

			if (*p == ' ') {
				p++;
				break;
			}

			if (!*p)
				die2(10, nk, "unexpected null after colon");
		}
		*q++ = c;
		if (q - key >= 256)
			die2(10, nk, ">= 256 bytes");
	}
	*q = 0;

	q = value;
	while (*p != '\n') {
		char c;

		c = *p++;
		if (!c)
			die2(10, nv, "unexpected null character");
		*q++ = c;
		if (q - value >= 32768)
			die2(10, nv, ">= 32768 bytes");
	}
	*q = 0;

	input = ++p;
}

int
main(int argc, char **argv)
{
	size_t len;
	char *sz;
	int input_size = 0;

EXEC SQL BEGIN DECLARE SECTION;
	char *blob;
	char *exit_status;

	char key[257];
	char value[32768];
EXEC SQL END DECLARE SECTION;

	if (argc != 4)
		die(EXIT_BAD_ARGC, "wrong number of arguments");

	close(1);

	//  parse the pdf udig as argv[1]

	blob = argv[1];
	len = strlen(blob);
	if (len < 34 || len > 264 || strchr(blob, ':') == NULL)
		die2(EXIT_BAD_UDIG, "syntax error in pdf udig", blob);

	exit_status = argv[2];

	//  scan the input blob size.
	//  Note: need to move this code to ../../common.c

	sz = argv[3];
	if (sz[0]) {
		if (sz[0] == '0' && !sz[1])
			input_size = 0;
		else {
			static char bad_atoi[] = "atoi(input blob size) <= 0";

			input_size = atoi(sz);
			if (input_size <= 0)
				die2(EXIT_BAD_SIZE, bad_atoi, sz);
		}
	} else
		die(EXIT_BAD_SIZE, "input size is empty");

	//  allocate the mime fields buffer plus null byte

	input = malloc(input_size + 1);
	if (input == NULL)
		die2(EXIT_BAD_MALLOC, "malloc(input blob) failed", sz);
	input[input_size] = 0;
	input_limit = input + input_size;

	_read_blob(0, input, input_size);

	EXEC SQL WHENEVER SQLERROR CALL _ecpg_sql_error(
		(struct _ecpg_sql_state_fault *)0);
	EXEC SQL WHENEVER SQLWARNING CALL _ecpg_sql_warning(no_warn);
	EXEC SQL CONNECT TO default;

	EXEC SQL BEGIN TRANSACTION;

	/*
	 *  Merge blob into fffile.file_type table.
	 */
	EXEC SQL INSERT INTO pdfbox2.pddocument_information_metadata(
		blob,
		exit_status
	  ) VALUES (
		:blob,
		:exit_status::smallint
	  )
  	  ON CONFLICT
  		DO NOTHING
	;
	while (input < input_limit) {
		key[0] = value[0] = 0;
		scan(key, value);

		EXEC SQL INSERT INTO
		  pdfbox2.pddocument_information_metadata_custom (
		  	blob,
		      	key,
			value
		) VALUEs (
			:blob,
			:key,
			:value
		)
		ON CONFLICT
			DO NOTHING
		;
	}
	EXEC SQL END TRANSACTION;

	_exit(EXIT_OK);
}
