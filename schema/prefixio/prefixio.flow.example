#
#  Synopsis:
#	Route blobs into other schemas based upon patterns in the byte prefix.
#  Description:
#	Blob may be routed to other schemas based upon values in the the
#	first 32 bytes of of the blob.  See the table setspace.byte_prefix_32.
#	Recipes may also assume that the core byte oriented setspace tables
#	have already been populated:
#
#		setspace.{byte_bitmap, byte_count, is_utf8}
#
#	Since most routing rules are immutable, the queries are highly
#	cacheable.  cool.
#
#  Usage:
#  	flowd server prefixio.conf
#  See:
#  	schema.sql
#  Note:
#	Only need to append requests that proof existence.
#

boot
{
	brr_capacity = 256;
	flow_worker_count = 32;

	#
	#  No processes are invoked
	#
	#  Note:
	#	Since no workers can we set to 0?
	#
	os_exec_worker_count = 1;
	os_exec_capacity = 1;

	xdr_roll_duration = "24h";
	fdr_roll_duration = "24h";
	qdr_roll_duration = "24h";

	heartbeat_duration = "10s";
}

sql database setspace
{
	driver_name = "postgres";
	data_source_name =
		"fallback_application_name=prefixio.flow sslmode=disable";
	max_idle_conns = 0;
	max_open_conns = 16;
}

tail brr
{
	path = "spool/setspace.brr";
}

#  Is the utf8 blob framed with json object or array chars?
#
#  Note:
#	We only consult 32 bytes of prefix and suffix of the blob.
#	This implies we will miss json blobs with long leading chunks of
#	white space.  Need add another recipe for such patterns.
#

sql query is_json_object_or_array row
{
	statement = `
SELECT EXISTS (
  WITH utf8wf AS (
    SELECT
  	blob
      FROM
    	setspace.is_utf8wf
      WHERE
	is_utf8 IS TRUE
	AND
	blob = $1::udig
  )
  SELECT
	u8.blob
    FROM
  	utf8wf u8
	  JOIN setspace.byte_prefix_32 p32 ON (p32.blob = u8.blob)
	  JOIN setspace.byte_suffix_32 s32 ON (s32.blob = u8.blob)
	  LEFT OUTER JOIN jsonorg.checker_255 js ON (js.blob = u8.blob)
    WHERE
    	/*
	 *  Consult the hex versions of the prefix/suffix, sine
	 *  we may have malformed utf8 due to truncating at 32 bytes.
	 */
	((	--  utf8 framed with {}

		p32.prefix::text ~ '^\\x(09|0a|20|0d)*7b'
		AND
		s32.suffix::text ~ '^\\x.*7d(09|0a|20|0d)*$'
	)
	OR
	(	--  utf8 framed with []

		p32.prefix::text ~ '^\\x(09|0a|20|0d)*5b'
		AND
		s32.suffix::text ~ '^\\x.*5d(09|0a|20|0d)*$'
	))
	AND
	js.blob IS NULL
);
	`;

	result row is (
		answer bool
	);
}

query is_json_object_or_array(brr.udig);

command append_jsonorg_brr
{
	path = "append-brr";
	argv = (
		"../jsonorg/spool/prefixio.brr"
	);
}

call append_jsonorg_brr(
	brr.start_time,
	brr.netflow,
	brr.verb,
	brr.udig,
	brr.chat_history,
	brr.blob_size,
	brr.wall_duration
) when
	is_json_object_or_array.answer == true
;

command append_pdfbox_brr
{
	path = "append-brr";
	argv = (
		"../pdfbox/spool/prefixio.brr"
	);
}

#
#  The prefix of blob matches '^%PDF-'
#
sql query prefix_is_percentPDF row
{
	statement = `

	SELECT
		substring(prefix, 1, 5) = '\x255044462d'  -- %PDF
	  from
	  	setspace.byte_prefix_32
	  where
	  	blob = $1::udig
	`;

	result row is (
		answer bool
	);
}

query prefix_is_percentPDF(brr.udig);

call append_pdfbox_brr(
	brr.start_time,
	brr.netflow,
	brr.verb,
	brr.udig,
	brr.chat_history,
	brr.blob_size,
	brr.wall_duration
) when
	prefix_is_percentPDF.answer == true
;
